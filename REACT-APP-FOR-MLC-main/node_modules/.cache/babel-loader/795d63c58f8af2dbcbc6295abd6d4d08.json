{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar strRotate = Lib.strRotate;\nvar strTranslate = Lib.strTranslate;\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Plots = require('../plots');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar setConvertCartesian = require('../cartesian/set_convert');\n\nvar setConvertPolar = require('./set_convert');\n\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\n\nvar dragBox = require('../cartesian/dragbox');\n\nvar dragElement = require('../../components/dragelement');\n\nvar Fx = require('../../components/fx');\n\nvar Titles = require('../../components/titles');\n\nvar prepSelect = require('../cartesian/select').prepSelect;\n\nvar selectOnClick = require('../cartesian/select').selectOnClick;\n\nvar clearSelect = require('../cartesian/select').clearSelect;\n\nvar setCursor = require('../../lib/setcursor');\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nvar smithHelpers = require('../smith/helpers');\n\nvar smith = smithHelpers.smith;\nvar reactanceArc = smithHelpers.reactanceArc;\nvar resistanceArc = smithHelpers.resistanceArc;\nvar smithTransform = smithHelpers.smithTransform;\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\nfunction Polar(gd, id, isSmith) {\n  this.isSmith = isSmith || false;\n  this.id = id;\n  this.gd = gd;\n  this._hasClipOnAxisFalse = null;\n  this.vangles = null;\n  this.radialAxisAngle = null;\n  this.traceHash = {};\n  this.layers = {};\n  this.clipPaths = {};\n  this.clipIds = {};\n  this.viewInitial = {};\n  var fullLayout = gd._fullLayout;\n  var clipIdBase = 'clip' + fullLayout._uid + id;\n  this.clipIds.forTraces = clipIdBase + '-for-traces';\n  this.clipPaths.forTraces = fullLayout._clips.append('clipPath').attr('id', this.clipIds.forTraces);\n  this.clipPaths.forTraces.append('path');\n  this.framework = fullLayout['_' + (isSmith ? 'smith' : 'polar') + 'layer'].append('g').attr('class', id);\n\n  this.getHole = function (s) {\n    return this.isSmith ? 0 : s.hole;\n  };\n\n  this.getSector = function (s) {\n    return this.isSmith ? [0, 360] : s.sector;\n  };\n\n  this.getRadial = function (s) {\n    return this.isSmith ? s.realaxis : s.radialaxis;\n  };\n\n  this.getAngular = function (s) {\n    return this.isSmith ? s.imaginaryaxis : s.angularaxis;\n  };\n\n  if (!isSmith) {\n    // unfortunately, we have to keep track of some axis tick settings\n    // as polar subplots do not implement the 'ticks' editType\n    this.radialTickLayout = null;\n    this.angularTickLayout = null;\n  }\n}\n\nvar proto = Polar.prototype;\n\nmodule.exports = function createPolar(gd, id, isSmith) {\n  return new Polar(gd, id, isSmith);\n};\n\nproto.plot = function (polarCalcData, fullLayout) {\n  var _this = this;\n\n  var polarLayout = fullLayout[_this.id];\n  var found = false;\n\n  for (var i = 0; i < polarCalcData.length; i++) {\n    var trace = polarCalcData[i][0].trace;\n\n    if (trace.cliponaxis === false) {\n      found = true;\n      break;\n    }\n  }\n\n  _this._hasClipOnAxisFalse = found;\n\n  _this.updateLayers(fullLayout, polarLayout);\n\n  _this.updateLayout(fullLayout, polarLayout);\n\n  Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n\n  _this.updateFx(fullLayout, polarLayout);\n\n  if (_this.isSmith) {\n    delete polarLayout.realaxis.range;\n    delete polarLayout.imaginaryaxis.range;\n  }\n};\n\nproto.updateLayers = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var isSmith = _this.isSmith;\n  var layers = _this.layers;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var angularLayout = _this.getAngular(polarLayout);\n\n  var layerNames = constants.layerNames;\n  var frontPlotIndex = layerNames.indexOf('frontplot');\n  var layerData = layerNames.slice(0, frontPlotIndex);\n  var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n  var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n  if (isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (isRadialAxisBelowTraces) layerData.push('radial-axis');\n  layerData.push('frontplot');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-axis');\n  var subLayer = (isSmith ? 'smith' : 'polar') + 'sublayer';\n\n  var join = _this.framework.selectAll('.' + subLayer).data(layerData, String);\n\n  join.enter().append('g').attr('class', function (d) {\n    return subLayer + ' ' + d;\n  }).each(function (d) {\n    var sel = layers[d] = d3.select(this);\n\n    switch (d) {\n      case 'frontplot':\n        // TODO add option to place in 'backplot' layer??\n        if (!isSmith) {\n          sel.append('g').classed('barlayer', true);\n        }\n\n        sel.append('g').classed('scatterlayer', true);\n        break;\n\n      case 'backplot':\n        sel.append('g').classed('maplayer', true);\n        break;\n\n      case 'plotbg':\n        layers.bg = sel.append('path');\n        break;\n\n      case 'radial-grid':\n        sel.style('fill', 'none');\n        break;\n\n      case 'angular-grid':\n        sel.style('fill', 'none');\n        break;\n\n      case 'radial-line':\n        sel.append('line').style('fill', 'none');\n        break;\n\n      case 'angular-line':\n        sel.append('path').style('fill', 'none');\n        break;\n    }\n  });\n  join.order();\n};\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - getRadial(polarLayout) (aka radialLayout in this file):\n * - getAngular(polarLayout) (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends getRadial(polarLayout), adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends getAngular(polarLayout), adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\n\n\nproto.updateLayout = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var layers = _this.layers;\n  var gs = fullLayout._size; // axis attributes\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var angularLayout = _this.getAngular(polarLayout); // layout domains\n\n\n  var xDomain = polarLayout.domain.x;\n  var yDomain = polarLayout.domain.y; // offsets from paper edge to layout domain box\n\n  _this.xOffset = gs.l + gs.w * xDomain[0];\n  _this.yOffset = gs.t + gs.h * (1 - yDomain[1]); // lengths of the layout domain box\n\n  var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n  var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]); // sector to plot\n\n  var sector = _this.getSector(polarLayout);\n\n  _this.sectorInRad = sector.map(deg2rad);\n  var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n  var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n  var dySectorBBox = sectorBBox[3] - sectorBBox[1]; // aspect ratios\n\n  var arDomain = yLength / xLength;\n  var arSector = Math.abs(dySectorBBox / dxSectorBBox); // actual lengths and domains of subplot box\n\n  var xLength2, yLength2;\n  var xDomain2, yDomain2;\n  var gap;\n\n  if (arDomain > arSector) {\n    xLength2 = xLength;\n    yLength2 = xLength * arSector;\n    gap = (yLength - yLength2) / gs.h / 2;\n    xDomain2 = [xDomain[0], xDomain[1]];\n    yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n  } else {\n    xLength2 = yLength / arSector;\n    yLength2 = yLength;\n    gap = (xLength - xLength2) / gs.w / 2;\n    xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n    yDomain2 = [yDomain[0], yDomain[1]];\n  }\n\n  _this.xLength2 = xLength2;\n  _this.yLength2 = yLength2;\n  _this.xDomain2 = xDomain2;\n  _this.yDomain2 = yDomain2; // actual offsets from paper edge to the subplot box top-left corner\n\n  var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n  var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]); // circle radius in px\n\n  var radius = _this.radius = xLength2 / dxSectorBBox; // 'inner' radius in px (when polar.hole is set)\n\n  var innerRadius = _this.innerRadius = _this.getHole(polarLayout) * radius; // circle center position in px\n\n  var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n  var cy = _this.cy = yOffset2 + radius * sectorBBox[3]; // circle center in the coordinate system of plot area\n\n  var cxx = _this.cxx = cx - xOffset2;\n  var cyy = _this.cyy = cy - yOffset2;\n  var side = radialLayout.side;\n  var trueSide;\n\n  if (side === 'counterclockwise') {\n    trueSide = side;\n    side = 'top';\n  } else if (side === 'clockwise') {\n    trueSide = side;\n    side = 'bottom';\n  }\n\n  _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n    // make this an 'x' axis to make positioning (especially rotation) easier\n    _id: 'x',\n    // convert to 'x' axis equivalent\n    side: side,\n    // keep track of real side\n    _trueSide: trueSide,\n    // spans length 1 radius\n    domain: [innerRadius / gs.w, radius / gs.w]\n  });\n  _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n    side: 'right',\n    // to get auto nticks right\n    domain: [0, Math.PI],\n    // don't pass through autorange logic\n    autorange: false\n  });\n\n  _this.doAutoRange(fullLayout, polarLayout); // N.B. this sets _this.vangles\n\n\n  _this.updateAngularAxis(fullLayout, polarLayout); // N.B. this sets _this.radialAxisAngle\n\n\n  _this.updateRadialAxis(fullLayout, polarLayout);\n\n  _this.updateRadialAxisTitle(fullLayout, polarLayout);\n\n  _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'x',\n    domain: xDomain2\n  });\n  _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'y',\n    domain: yDomain2\n  });\n\n  var dPath = _this.pathSubplot();\n\n  _this.clipPaths.forTraces.select('path').attr('d', dPath).attr('transform', strTranslate(cxx, cyy));\n\n  layers.frontplot.attr('transform', strTranslate(xOffset2, yOffset2)).call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n  layers.bg.attr('d', dPath).attr('transform', strTranslate(cx, cy)).call(Color.fill, polarLayout.bgcolor);\n};\n\nproto.mockAxis = function (fullLayout, polarLayout, axLayout, opts) {\n  var ax = Lib.extendFlat({}, axLayout, opts);\n  setConvertPolar(ax, polarLayout, fullLayout);\n  return ax;\n};\n\nproto.mockCartesianAxis = function (fullLayout, polarLayout, opts) {\n  var _this = this;\n\n  var isSmith = _this.isSmith;\n  var axId = opts._id;\n  var ax = Lib.extendFlat({\n    type: 'linear'\n  }, opts);\n  setConvertCartesian(ax, fullLayout);\n  var bboxIndices = {\n    x: [0, 2],\n    y: [1, 3]\n  };\n\n  ax.setRange = function () {\n    var sectorBBox = _this.sectorBBox;\n    var ind = bboxIndices[axId];\n    var rl = _this.radialAxis._rl;\n\n    var drl = (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout));\n\n    ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n  };\n\n  ax.isPtWithinRange = axId === 'x' && !isSmith ? function (d) {\n    return _this.isPtInside(d);\n  } : function () {\n    return true;\n  };\n  ax.setRange();\n  ax.setScale();\n  return ax;\n};\n\nproto.doAutoRange = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var radialAxis = _this.radialAxis;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  doAutoRange(gd, radialAxis);\n  var rng = radialAxis.range;\n  radialLayout.range = rng.slice();\n  radialLayout._input.range = rng.slice();\n  radialAxis._rl = [radialAxis.r2l(rng[0], null, 'gregorian'), radialAxis.r2l(rng[1], null, 'gregorian')];\n};\n\nproto.updateRadialAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var a0 = mod(_this.getSector(polarLayout)[0], 360);\n  var ax = _this.radialAxis;\n  var hasRoomForIt = innerRadius < radius;\n  var isSmith = _this.isSmith;\n\n  if (!isSmith) {\n    _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n\n    _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n\n    ax.setGeometry();\n  } // rotate auto tick labels by 180 if in quadrant II and III to make them\n  // readable from left-to-right\n  //\n  // TODO try moving deeper in Axes.drawLabels for better results?\n\n\n  if (ax.tickangle === 'auto' && a0 > 90 && a0 <= 270) {\n    ax.tickangle = 180;\n  } // easier to set rotate angle with custom translate function\n\n\n  var transFn = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([d.x, 0]));\n    return strTranslate(t[0] - cx, t[1] - cy);\n  } : function (d) {\n    return strTranslate(ax.l2p(d.x) + innerRadius, 0);\n  }; // set special grid path function\n\n  var gridPathFn = isSmith ? function (d) {\n    return resistanceArc(_this, d.x, -Infinity, Infinity);\n  } : function (d) {\n    return _this.pathArc(ax.r2p(d.x) + innerRadius);\n  };\n  var newTickLayout = strTickLayout(radialLayout);\n\n  if (_this.radialTickLayout !== newTickLayout) {\n    layers['radial-axis'].selectAll('.xtick').remove();\n    _this.radialTickLayout = newTickLayout;\n  }\n\n  if (hasRoomForIt) {\n    ax.setScale();\n    var labelShift = 0;\n    var vals = isSmith ? (ax.tickvals || []).filter(function (x) {\n      // filter negative\n      return x >= 0;\n    }).map(function (x) {\n      return Axes.tickText(ax, x, true, false);\n    }) : Axes.calcTicks(ax);\n    var valsClipped = isSmith ? vals : Axes.clipEnds(ax, vals);\n    var tickSign = Axes.getTickSigns(ax)[2];\n\n    if (isSmith) {\n      if (ax.ticks === 'top' && ax.side === 'bottom' || ax.ticks === 'bottom' && ax.side === 'top') {\n        // invert sign\n        tickSign = -tickSign;\n      }\n\n      if (ax.ticks === 'top' && ax.side === 'top') labelShift = -ax.ticklen;\n      if (ax.ticks === 'bottom' && ax.side === 'bottom') labelShift = ax.ticklen;\n    }\n\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      path: Axes.makeTickPath(ax, 0, tickSign),\n      transFn: transFn,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: valsClipped,\n      layer: layers['radial-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      transFn: transFn,\n      labelFns: Axes.makeLabelFns(ax, labelShift)\n    });\n  } // stash 'actual' radial axis angle for drag handlers (in degrees)\n\n\n  var angle = _this.radialAxisAngle = _this.vangles ? rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) : radialLayout.angle;\n  var tLayer = strTranslate(cx, cy);\n  var tLayer2 = tLayer + strRotate(-angle);\n  updateElement(layers['radial-axis'], hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks), {\n    transform: tLayer2\n  });\n  updateElement(layers['radial-grid'], hasRoomForIt && radialLayout.showgrid, {\n    transform: isSmith ? '' : tLayer\n  });\n  updateElement(layers['radial-line'].select('line'), hasRoomForIt && radialLayout.showline, {\n    x1: isSmith ? -radius : innerRadius,\n    y1: 0,\n    x2: radius,\n    y2: 0,\n    transform: tLayer2\n  }).attr('stroke-width', radialLayout.linewidth).call(Color.stroke, radialLayout.linecolor);\n};\n\nproto.updateRadialAxisTitle = function (fullLayout, polarLayout, _angle) {\n  if (this.isSmith) return;\n\n  var _this = this;\n\n  var gd = _this.gd;\n  var radius = _this.radius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var titleClass = _this.id + 'title';\n  var pad = 0; // Hint: no need to check if there is in fact a title.text set\n  // because if plot is editable, pad needs to be calculated anyways\n  // to properly show placeholder text when title is empty.\n\n  if (radialLayout.title) {\n    var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n    var ts = radialLayout.title.font.size;\n    var side = radialLayout.side;\n    pad = side === 'top' ? ts : side === 'counterclockwise' ? -(h + ts * 0.4) : h + ts * 0.8;\n  }\n\n  var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n  var angleRad = deg2rad(angle);\n  var cosa = Math.cos(angleRad);\n  var sina = Math.sin(angleRad);\n  var x = cx + radius / 2 * cosa + pad * sina;\n  var y = cy - radius / 2 * sina + pad * cosa;\n  _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n    propContainer: radialLayout,\n    propName: _this.id + '.radialaxis.title',\n    placeholder: _(gd, 'Click to enter radial axis title'),\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    },\n    transform: {\n      rotate: -angle\n    }\n  });\n};\n\nproto.updateAngularAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n\n  var angularLayout = _this.getAngular(polarLayout);\n\n  var ax = _this.angularAxis;\n  var isSmith = _this.isSmith;\n\n  if (!isSmith) {\n    _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n\n    ax.setGeometry();\n    ax.setScale();\n  } // 't'ick to 'g'eometric radians is used all over the place here\n\n\n  var t2g = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    return Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n  } : function (d) {\n    return ax.t2g(d.x);\n  }; // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n\n  if (ax.type === 'linear' && ax.thetaunit === 'radians') {\n    ax.tick0 = rad2deg(ax.tick0);\n    ax.dtick = rad2deg(ax.dtick);\n  }\n\n  var _transFn = function (rad) {\n    return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n  };\n\n  var transFn = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    return strTranslate(t[0], t[1]);\n  } : function (d) {\n    return _transFn(t2g(d));\n  };\n  var transFn2 = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    var rad = Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n    return strTranslate(t[0], t[1]) + strRotate(-rad2deg(rad));\n  } : function (d) {\n    var rad = t2g(d);\n    return _transFn(rad) + strRotate(-rad2deg(rad));\n  };\n  var gridPathFn = isSmith ? function (d) {\n    return reactanceArc(_this, d.x, 0, Infinity);\n  } : function (d) {\n    var rad = t2g(d);\n    var cosRad = Math.cos(rad);\n    var sinRad = Math.sin(rad);\n    return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] + 'L' + [cx + radius * cosRad, cy - radius * sinRad];\n  };\n  var out = Axes.makeLabelFns(ax, 0);\n  var labelStandoff = out.labelStandoff;\n  var labelFns = {};\n\n  labelFns.xFn = function (d) {\n    var rad = t2g(d);\n    return Math.cos(rad) * labelStandoff;\n  };\n\n  labelFns.yFn = function (d) {\n    var rad = t2g(d);\n    var ff = Math.sin(rad) > 0 ? 0.2 : 1;\n    return -Math.sin(rad) * (labelStandoff + d.fontSize * ff) + Math.abs(Math.cos(rad)) * (d.fontSize * MID_SHIFT);\n  };\n\n  labelFns.anchorFn = function (d) {\n    var rad = t2g(d);\n    var cos = Math.cos(rad);\n    return Math.abs(cos) < 0.1 ? 'middle' : cos > 0 ? 'start' : 'end';\n  };\n\n  labelFns.heightFn = function (d, a, h) {\n    var rad = t2g(d);\n    return -0.5 * (1 + Math.sin(rad)) * h;\n  };\n\n  var newTickLayout = strTickLayout(angularLayout);\n\n  if (_this.angularTickLayout !== newTickLayout) {\n    layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n    _this.angularTickLayout = newTickLayout;\n  }\n\n  var vals = isSmith ? [Infinity].concat(ax.tickvals || []).map(function (x) {\n    return Axes.tickText(ax, x, true, false);\n  }) : Axes.calcTicks(ax);\n\n  if (isSmith) {\n    vals[0].text = '∞';\n    vals[0].fontSize *= 1.75;\n  } // angle of polygon vertices in geometric radians (null means circles)\n  // TODO what to do when ax.period > ax._categories ??\n\n\n  var vangles;\n\n  if (polarLayout.gridshape === 'linear') {\n    vangles = vals.map(t2g); // ax._vals should be always ordered, make them\n    // always turn counterclockwise for convenience here\n\n    if (Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n      vangles = vangles.slice().reverse();\n    }\n  } else {\n    vangles = null;\n  }\n\n  _this.vangles = vangles; // Use tickval filter for category axes instead of tweaking\n  // the range w.r.t sector, so that sectors that cross 360 can\n  // show all their ticks.\n\n  if (ax.type === 'category') {\n    vals = vals.filter(function (d) {\n      return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n    });\n  }\n\n  if (ax.visible) {\n    var tickSign = ax.ticks === 'inside' ? -1 : 1;\n    var pad = (ax.linewidth || 1) / 2;\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      path: 'M' + tickSign * pad + ',0h' + tickSign * ax.ticklen,\n      transFn: transFn2,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: vals,\n      layer: layers['angular-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      repositionOnUpdate: true,\n      transFn: transFn,\n      labelFns: labelFns\n    });\n  } // TODO maybe two arcs is better here?\n  // maybe split style attributes between inner and outer angular axes?\n\n\n  updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n    d: _this.pathSubplot(),\n    transform: strTranslate(cx, cy)\n  }).attr('stroke-width', angularLayout.linewidth).call(Color.stroke, angularLayout.linecolor);\n};\n\nproto.updateFx = function (fullLayout, polarLayout) {\n  if (!this.gd._context.staticPlot) {\n    var hasDrag = !this.isSmith;\n\n    if (hasDrag) {\n      this.updateAngularDrag(fullLayout);\n      this.updateRadialDrag(fullLayout, polarLayout, 0);\n      this.updateRadialDrag(fullLayout, polarLayout, 1);\n    }\n\n    this.updateHoverAndMainDrag(fullLayout);\n  }\n};\n\nproto.updateHoverAndMainDrag = function (fullLayout) {\n  var _this = this;\n\n  var isSmith = _this.isSmith;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var zoomlayer = fullLayout._zoomlayer;\n  var MINZOOM = constants.MINZOOM;\n  var OFFEDGE = constants.OFFEDGE;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var sectorInRad = _this.sectorInRad;\n  var vangles = _this.vangles;\n  var radialAxis = _this.radialAxis;\n  var clampTiny = helpers.clampTiny;\n  var findXYatLength = helpers.findXYatLength;\n  var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n  var chw = constants.cornerHalfWidth;\n  var chl = constants.cornerLen / 2;\n  var scaleX;\n  var scaleY;\n  var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', 'crosshair');\n  d3.select(mainDrag).attr('d', _this.pathSubplot()).attr('transform', strTranslate(cx, cy));\n\n  mainDrag.onmousemove = function (evt) {\n    Fx.hover(gd, evt, _this.id);\n    gd._fullLayout._lasthover = mainDrag;\n    gd._fullLayout._hoversubplot = _this.id;\n  };\n\n  mainDrag.onmouseout = function (evt) {\n    if (gd._dragging) return;\n    dragElement.unhover(gd, evt);\n  };\n\n  var dragOpts = {\n    element: mainDrag,\n    gd: gd,\n    subplot: _this.id,\n    plotinfo: {\n      id: _this.id,\n      xaxis: _this.xaxis,\n      yaxis: _this.yaxis\n    },\n    xaxes: [_this.xaxis],\n    yaxes: [_this.yaxis]\n  }; // mouse px position at drag start (0), move (1)\n\n  var x0, y0; // radial distance from circle center at drag start (0), move (1)\n\n  var r0, r1; // zoombox persistent quantities\n\n  var path0, dimmed, lum; // zoombox, corners elements\n\n  var zb, corners;\n\n  function norm(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n\n  function xy2r(x, y) {\n    return norm(x - cxx, y - cyy);\n  }\n\n  function xy2a(x, y) {\n    return Math.atan2(cyy - y, x - cxx);\n  }\n\n  function ra2xy(r, a) {\n    return [r * Math.cos(a), r * Math.sin(-a)];\n  }\n\n  function pathCorner(r, a) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var da = chl / r;\n    var am = a - da;\n    var ap = a + da;\n    var rb = Math.max(0, Math.min(r, radius));\n    var rm = rb - chw;\n    var rp = rb + chw;\n    return 'M' + ra2xy(rm, am) + 'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) + 'L' + ra2xy(rp, ap) + 'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) + 'Z';\n  } // (x,y) is the pt at middle of the va0 <-> va1 edge\n  //\n  // ... we could eventually add another mode for cursor\n  // angles 'close to' enough to a particular vertex.\n\n\n  function pathCornerForPolygons(r, va0, va1) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var xy0 = ra2xy(r, va0);\n    var xy1 = ra2xy(r, va1);\n    var x = clampTiny((xy0[0] + xy1[0]) / 2);\n    var y = clampTiny((xy0[1] + xy1[1]) / 2);\n    var innerPts, outerPts;\n\n    if (x && y) {\n      var m = y / x;\n      var mperp = -1 / m;\n      var midPts = findXYatLength(chw, m, x, y);\n      innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n      outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n    } else {\n      var dx, dy;\n\n      if (y) {\n        // horizontal handles\n        dx = chl;\n        dy = chw;\n      } else {\n        // vertical handles\n        dx = chw;\n        dy = chl;\n      }\n\n      innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n      outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n    }\n\n    return 'M' + innerPts.join('L') + 'L' + outerPts.reverse().join('L') + 'Z';\n  }\n\n  function zoomPrep() {\n    r0 = null;\n    r1 = null;\n    path0 = _this.pathSubplot();\n    dimmed = false;\n    var polarLayoutNow = gd._fullLayout[_this.id];\n    lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n    zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n    zb.attr('fill-rule', 'evenodd');\n    corners = dragBox.makeCorners(zoomlayer, cx, cy);\n    clearSelect(gd);\n  } // N.B. this sets scoped 'r0' and 'r1'\n  // return true if 'valid' zoom distance, false otherwise\n\n\n  function clampAndSetR0R1(rr0, rr1) {\n    rr1 = Math.max(Math.min(rr1, radius), innerRadius); // starting or ending drag near center (outer edge),\n    // clamps radial distance at origin (at r=radius)\n\n    if (rr0 < OFFEDGE) rr0 = 0;else if (radius - rr0 < OFFEDGE) rr0 = radius;else if (rr1 < OFFEDGE) rr1 = 0;else if (radius - rr1 < OFFEDGE) rr1 = radius; // make sure r0 < r1,\n    // to get correct fill pattern in path1 below\n\n    if (Math.abs(rr1 - rr0) > MINZOOM) {\n      if (rr0 < rr1) {\n        r0 = rr0;\n        r1 = rr1;\n      } else {\n        r0 = rr1;\n        r1 = rr0;\n      }\n\n      return true;\n    } else {\n      r0 = null;\n      r1 = null;\n      return false;\n    }\n  }\n\n  function applyZoomMove(path1, cpath) {\n    path1 = path1 || path0;\n    cpath = cpath || 'M0,0Z';\n    zb.attr('d', path1);\n    corners.attr('d', cpath);\n    dragBox.transitionZoombox(zb, corners, dimmed, lum);\n    dimmed = true;\n    var updateObj = {};\n    computeZoomUpdates(updateObj);\n    gd.emit('plotly_relayouting', updateObj);\n  }\n\n  function zoomMove(dx, dy) {\n    dx = dx * scaleX;\n    dy = dy * scaleY;\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var rr0 = xy2r(x0, y0);\n    var rr1 = Math.min(xy2r(x1, y1), radius);\n    var a0 = xy2a(x0, y0);\n    var path1;\n    var cpath;\n\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0); // keep 'starting' angle\n\n      cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n    }\n\n    applyZoomMove(path1, cpath);\n  }\n\n  function findPolygonRadius(x, y, va0, va1) {\n    var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n    return norm(xy[0], xy[1]);\n  }\n\n  function zoomMoveForPolygons(dx, dy) {\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var a0 = xy2a(x0, y0);\n    var a1 = xy2a(x1, y1);\n    var vangles0 = findEnclosingVertexAngles(a0, vangles);\n    var vangles1 = findEnclosingVertexAngles(a1, vangles);\n    var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n    var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n    var path1;\n    var cpath;\n\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0); // keep 'starting' angle here too\n\n      cpath = [pathCornerForPolygons(r0, vangles0[0], vangles0[1]), pathCornerForPolygons(r1, vangles0[0], vangles0[1])].join(' ');\n    }\n\n    applyZoomMove(path1, cpath);\n  }\n\n  function zoomDone() {\n    dragBox.removeZoombox(gd);\n    if (r0 === null || r1 === null) return;\n    var updateObj = {};\n    computeZoomUpdates(updateObj);\n    dragBox.showDoubleClickNotifier(gd);\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n\n  function computeZoomUpdates(update) {\n    var rl = radialAxis._rl;\n    var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n    var newRng = [rl[0] + (r0 - innerRadius) * m, rl[0] + (r1 - innerRadius) * m];\n    update[_this.id + '.radialaxis.range'] = newRng;\n  }\n\n  function zoomClick(numClicks, evt) {\n    var clickMode = gd._fullLayout.clickmode;\n    dragBox.removeZoombox(gd); // TODO double once vs twice logic (autorange vs fixed range)\n\n    if (numClicks === 2) {\n      var updateObj = {};\n\n      for (var k in _this.viewInitial) {\n        updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n      }\n\n      gd.emit('plotly_doubleclick', null);\n      Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    if (clickMode.indexOf('select') > -1 && numClicks === 1) {\n      selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n    }\n\n    if (clickMode.indexOf('event') > -1) {\n      Fx.click(gd, evt, _this.id);\n    }\n  }\n\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var dragModeNow = gd._fullLayout.dragmode;\n    var bbox = mainDrag.getBoundingClientRect();\n\n    gd._fullLayout._calcInverseTransform(gd);\n\n    var inverse = gd._fullLayout._invTransform;\n    scaleX = gd._fullLayout._invScaleX;\n    scaleY = gd._fullLayout._invScaleY;\n    var transformedCoords = Lib.apply3DTransform(inverse)(startX - bbox.left, startY - bbox.top);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1]; // need to offset x/y as bbox center does not\n    // match origin for asymmetric polygons\n\n    if (vangles) {\n      var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n      x0 += cxx + offset[0];\n      y0 += cyy + offset[1];\n    }\n\n    switch (dragModeNow) {\n      case 'zoom':\n        dragOpts.clickFn = zoomClick;\n\n        if (!isSmith) {\n          if (vangles) {\n            dragOpts.moveFn = zoomMoveForPolygons;\n          } else {\n            dragOpts.moveFn = zoomMove;\n          }\n\n          dragOpts.doneFn = zoomDone;\n          zoomPrep(evt, startX, startY);\n        }\n\n        break;\n\n      case 'select':\n      case 'lasso':\n        prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n        break;\n    }\n  };\n\n  dragElement.init(dragOpts);\n};\n\nproto.updateRadialDrag = function (fullLayout, polarLayout, rngIndex) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialAxis = _this.radialAxis;\n  var bl = constants.radialDragBoxSize;\n  var bl2 = bl / 2;\n  if (!radialAxis.visible) return;\n  var angle0 = deg2rad(_this.radialAxisAngle);\n  var rl = radialAxis._rl;\n  var rl0 = rl[0];\n  var rl1 = rl[1];\n  var rbase = rl[rngIndex];\n  var m = 0.75 * (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout)) / radius;\n  var tx, ty, className;\n\n  if (rngIndex) {\n    tx = cx + (radius + bl2) * Math.cos(angle0);\n    ty = cy - (radius + bl2) * Math.sin(angle0);\n    className = 'radialdrag';\n  } else {\n    // the 'inner' box can get called:\n    // - when polar.hole>0\n    // - when polar.sector isn't a full circle\n    // otherwise it is hidden behind the main drag.\n    tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n    ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n    className = 'radialdrag-inner';\n  }\n\n  var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n  var dragOpts = {\n    element: radialDrag,\n    gd: gd\n  };\n  updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n    transform: strTranslate(tx, ty)\n  }); // move function (either rotate or re-range flavor)\n\n  var moveFn2; // rotate angle on done\n\n  var angle1; // re-range range[1] (or range[0]) on done\n\n  var rprime;\n\n  function moveFn(dx, dy) {\n    if (moveFn2) {\n      moveFn2(dx, dy);\n    } else {\n      var dvec = [dx, -dy];\n      var rvec = [Math.cos(angle0), Math.sin(angle0)];\n      var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec))); // mostly perpendicular motions rotate,\n      // mostly parallel motions re-range\n\n      if (!isNaN(comp)) {\n        moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n      }\n    }\n\n    var update = {};\n    computeRadialAxisUpdates(update);\n    gd.emit('plotly_relayouting', update);\n  }\n\n  function computeRadialAxisUpdates(update) {\n    if (angle1 !== null) {\n      update[_this.id + '.radialaxis.angle'] = angle1;\n    } else if (rprime !== null) {\n      update[_this.id + '.radialaxis.range[' + rngIndex + ']'] = rprime;\n    }\n  }\n\n  function doneFn() {\n    if (angle1 !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n    } else if (rprime !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n    }\n  }\n\n  function rotateMove(dx, dy) {\n    // disable for inner drag boxes\n    if (rngIndex === 0) return;\n    var x1 = tx + dx;\n    var y1 = ty + dy;\n    angle1 = Math.atan2(cy - y1, x1 - cx);\n    if (_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n    angle1 = rad2deg(angle1);\n    var transform = strTranslate(cx, cy) + strRotate(-angle1);\n    layers['radial-axis'].attr('transform', transform);\n    layers['radial-line'].select('line').attr('transform', transform);\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n\n    _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n  }\n\n  function rerangeMove(dx, dy) {\n    // project (dx, dy) unto unit radial axis vector\n    var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n    rprime = rbase - m * dr; // make sure rprime does not change the range[0] -> range[1] sign\n\n    if (m > 0 !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n      rprime = null;\n      return;\n    }\n\n    var fullLayoutNow = gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id]; // update radial range -> update c2g -> update _m,_b\n\n    radialAxis.range[rngIndex] = rprime;\n    radialAxis._rl[rngIndex] = rprime;\n\n    _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n\n    _this.xaxis.setRange();\n\n    _this.xaxis.setScale();\n\n    _this.yaxis.setRange();\n\n    _this.yaxis.setScale();\n\n    var hasRegl = false;\n\n    for (var traceType in _this.traceHash) {\n      var moduleCalcData = _this.traceHash[traceType];\n      var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n      var _module = moduleCalcData[0][0].trace._module;\n\n      _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n\n      if (Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n    }\n\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n  }\n\n  dragOpts.prepFn = function () {\n    moveFn2 = null;\n    angle1 = null;\n    rprime = null;\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearSelect(gd);\n  };\n\n  dragOpts.clampFn = function (dx, dy) {\n    if (Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n      dx = 0;\n      dy = 0;\n    }\n\n    return [dx, dy];\n  };\n\n  dragElement.init(dragOpts);\n};\n\nproto.updateAngularDrag = function (fullLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var angularAxis = _this.angularAxis;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var dbs = constants.angularDragBoxSize;\n  var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', 'move');\n  var dragOpts = {\n    element: angularDrag,\n    gd: gd\n  };\n  d3.select(angularDrag).attr('d', _this.pathAnnulus(radius, radius + dbs)).attr('transform', strTranslate(cx, cy)).call(setCursor, 'move');\n\n  function xy2a(x, y) {\n    return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n  } // scatter trace, points and textpoints selections\n\n\n  var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n  var scatterPoints = scatterTraces.selectAll('.point');\n  var scatterTextPoints = scatterTraces.selectAll('.textpoint'); // mouse px position at drag start (0), move (1)\n\n  var x0, y0; // angular axis angle rotation at drag start (0), move (1)\n\n  var rot0, rot1; // induced radial axis rotation (only used on polygon grids)\n\n  var rrot1; // angle about circle center at drag start\n\n  var a0;\n\n  function moveFn(dx, dy) {\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n    var x1 = x0 + dx * fullLayout._invScaleX;\n    var y1 = y0 + dy * fullLayout._invScaleY;\n    var a1 = xy2a(x1, y1);\n    var da = rad2deg(a1 - a0);\n    rot1 = rot0 + da;\n    layers.frontplot.attr('transform', strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy]));\n\n    if (_this.vangles) {\n      rrot1 = _this.radialAxisAngle + da;\n      var trans = strTranslate(cx, cy) + strRotate(-da);\n      var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n      layers.bg.attr('transform', trans);\n      layers['radial-grid'].attr('transform', trans);\n      layers['radial-axis'].attr('transform', trans2);\n      layers['radial-line'].select('line').attr('transform', trans2);\n\n      _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n    } else {\n      _this.clipPaths.forTraces.select('path').attr('transform', strTranslate(cxx, cyy) + strRotate(da));\n    } // 'un-rotate' marker and text points\n\n\n    scatterPoints.each(function () {\n      var sel = d3.select(this);\n      var xy = Drawing.getTranslate(sel);\n      sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n    });\n    scatterTextPoints.each(function () {\n      var sel = d3.select(this);\n      var tx = sel.select('text');\n      var xy = Drawing.getTranslate(sel); // N.B rotate -> translate ordering matters\n\n      sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n    }); // update rotation -> range -> _m,_b\n\n    angularAxis.rotation = Lib.modHalf(rot1, 360);\n\n    _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n\n    if (_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n      scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n    }\n\n    var hasRegl = false;\n\n    for (var traceType in _this.traceHash) {\n      if (Registry.traceIs(traceType, 'gl')) {\n        var moduleCalcData = _this.traceHash[traceType];\n        var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n        var _module = moduleCalcData[0][0].trace._module;\n\n        _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n\n        if (moduleCalcDataVisible.length) hasRegl = true;\n      }\n    }\n\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n\n    var update = {};\n    computeRotationUpdates(update);\n    gd.emit('plotly_relayouting', update);\n  }\n\n  function computeRotationUpdates(updateObj) {\n    updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n\n    if (_this.vangles) {\n      updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n    }\n  }\n\n  function doneFn() {\n    scatterTextPoints.select('text').attr('transform', null);\n    var updateObj = {};\n    computeRotationUpdates(updateObj);\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var polarLayoutNow = fullLayout[_this.id];\n    rot0 = polarLayoutNow.angularaxis.rotation;\n    var bbox = angularDrag.getBoundingClientRect();\n    x0 = startX - bbox.left;\n    y0 = startY - bbox.top;\n\n    gd._fullLayout._calcInverseTransform(gd);\n\n    var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    a0 = xy2a(x0, y0);\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearSelect(gd);\n  }; // I don't what we should do in this case, skip we now\n\n\n  if (_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n    dragOpts.prepFn = Lib.noop;\n    setCursor(d3.select(angularDrag), null);\n  }\n\n  dragElement.init(dragOpts);\n};\n\nproto.isPtInside = function (d) {\n  if (this.isSmith) return true;\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var thetag = this.angularAxis.c2g(d.theta);\n  var radialAxis = this.radialAxis;\n  var r = radialAxis.c2l(d.r);\n  var rl = radialAxis._rl;\n  var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n  return fn(r, thetag, rl, sectorInRad, vangles);\n};\n\nproto.pathArc = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSector = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathAnnulus = function (r0, r1) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n  return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSubplot = function () {\n  var r0 = this.innerRadius;\n  var r1 = this.radius;\n  return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\n\nproto.fillViewInitialKey = function (key, val) {\n  if (!(key in this.viewInitial)) {\n    this.viewInitial[key] = val;\n  }\n};\n\nfunction strTickLayout(axLayout) {\n  var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n  if ('side' in axLayout) out += axLayout.side;\n  return out;\n} // Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\n\n\nfunction computeSectorBBox(sector) {\n  var s0 = sector[0];\n  var s1 = sector[1];\n  var arc = s1 - s0;\n  var a0 = mod(s0, 360);\n  var a1 = a0 + arc;\n  var ax0 = Math.cos(deg2rad(a0));\n  var ay0 = Math.sin(deg2rad(a0));\n  var ax1 = Math.cos(deg2rad(a1));\n  var ay1 = Math.sin(deg2rad(a1));\n  var x0, y0, x1, y1;\n\n  if (a0 <= 90 && a1 >= 90 || a0 > 90 && a1 >= 450) {\n    y1 = 1;\n  } else if (ay0 <= 0 && ay1 <= 0) {\n    y1 = 0;\n  } else {\n    y1 = Math.max(ay0, ay1);\n  }\n\n  if (a0 <= 180 && a1 >= 180 || a0 > 180 && a1 >= 540) {\n    x0 = -1;\n  } else if (ax0 >= 0 && ax1 >= 0) {\n    x0 = 0;\n  } else {\n    x0 = Math.min(ax0, ax1);\n  }\n\n  if (a0 <= 270 && a1 >= 270 || a0 > 270 && a1 >= 630) {\n    y0 = -1;\n  } else if (ay0 >= 0 && ay1 >= 0) {\n    y0 = 0;\n  } else {\n    y0 = Math.min(ay0, ay1);\n  }\n\n  if (a1 >= 360) {\n    x1 = 1;\n  } else if (ax0 <= 0 && ax1 <= 0) {\n    x1 = 0;\n  } else {\n    x1 = Math.max(ax0, ax1);\n  }\n\n  return [x0, y0, x1, y1];\n}\n\nfunction snapToVertexAngle(a, vangles) {\n  var fn = function (v) {\n    return Lib.angleDist(a, v);\n  };\n\n  var ind = Lib.findIndexOfMin(vangles, fn);\n  return vangles[ind];\n}\n\nfunction updateElement(sel, showAttr, attrs) {\n  if (showAttr) {\n    sel.attr('display', null);\n    sel.attr(attrs);\n  } else if (sel) {\n    sel.attr('display', 'none');\n  }\n\n  return sel;\n}","map":{"version":3,"sources":["C:/Users/Ajax/Desktop/Praksa/React/REACT-APP-FOR-MLC-main/node_modules/plotly.js/src/plots/polar/polar.js"],"names":["d3","require","tinycolor","Registry","Lib","strRotate","strTranslate","Color","Drawing","Plots","Axes","setConvertCartesian","setConvertPolar","doAutoRange","dragBox","dragElement","Fx","Titles","prepSelect","selectOnClick","clearSelect","setCursor","clearGlCanvases","redrawReglTraces","MID_SHIFT","constants","helpers","smithHelpers","smith","reactanceArc","resistanceArc","smithTransform","_","mod","deg2rad","rad2deg","Polar","gd","id","isSmith","_hasClipOnAxisFalse","vangles","radialAxisAngle","traceHash","layers","clipPaths","clipIds","viewInitial","fullLayout","_fullLayout","clipIdBase","_uid","forTraces","_clips","append","attr","framework","getHole","s","hole","getSector","sector","getRadial","realaxis","radialaxis","getAngular","imaginaryaxis","angularaxis","radialTickLayout","angularTickLayout","proto","prototype","module","exports","createPolar","plot","polarCalcData","_this","polarLayout","found","i","length","trace","cliponaxis","updateLayers","updateLayout","generalUpdatePerTraceModule","updateFx","range","radialLayout","angularLayout","layerNames","frontPlotIndex","indexOf","layerData","slice","isAngularAxisBelowTraces","layer","isRadialAxisBelowTraces","push","subLayer","join","selectAll","data","String","enter","d","each","sel","select","classed","bg","style","order","gs","_size","xDomain","domain","x","yDomain","y","xOffset","l","w","yOffset","t","h","xLength","yLength","sectorInRad","map","sectorBBox","computeSectorBBox","dxSectorBBox","dySectorBBox","arDomain","arSector","Math","abs","xLength2","yLength2","xDomain2","yDomain2","gap","xOffset2","yOffset2","radius","innerRadius","cx","cy","cxx","cyy","side","trueSide","radialAxis","mockAxis","_id","_trueSide","angularAxis","PI","autorange","updateAngularAxis","updateRadialAxis","updateRadialAxisTitle","xaxis","mockCartesianAxis","yaxis","dPath","pathSubplot","frontplot","call","setClipUrl","fill","bgcolor","axLayout","opts","ax","extendFlat","axId","type","bboxIndices","setRange","ind","rl","_rl","drl","isPtWithinRange","isPtInside","setScale","rng","_input","r2l","a0","hasRoomForIt","fillViewInitialKey","angle","setGeometry","tickangle","transFn","l2p","gridPathFn","Infinity","pathArc","r2p","newTickLayout","strTickLayout","remove","labelShift","vals","tickvals","filter","tickText","calcTicks","valsClipped","clipEnds","tickSign","getTickSigns","ticks","ticklen","drawTicks","path","makeTickPath","crisp","drawGrid","noop","drawLabels","labelFns","makeLabelFns","snapToVertexAngle","tLayer","tLayer2","updateElement","showticklabels","transform","showgrid","showline","x1","y1","x2","y2","linewidth","stroke","linecolor","_angle","titleClass","pad","title","bBox","node","height","ts","font","size","undefined","angleRad","cosa","cos","sina","sin","draw","propContainer","propName","placeholder","attributes","rotate","rotation","t2g","atan2","thetaunit","tick0","dtick","_transFn","rad","transFn2","cosRad","sinRad","out","labelStandoff","xFn","yFn","ff","fontSize","anchorFn","heightFn","a","concat","text","gridshape","angleDelta","reverse","isAngleInsideSector","visible","repositionOnUpdate","_context","staticPlot","hasDrag","updateAngularDrag","updateRadialDrag","updateHoverAndMainDrag","zoomlayer","_zoomlayer","MINZOOM","OFFEDGE","clampTiny","findXYatLength","findEnclosingVertexAngles","chw","cornerHalfWidth","chl","cornerLen","scaleX","scaleY","mainDrag","makeDragger","onmousemove","evt","hover","_lasthover","_hoversubplot","onmouseout","_dragging","unhover","dragOpts","element","subplot","plotinfo","xaxes","yaxes","x0","y0","r0","r1","path0","dimmed","lum","zb","corners","norm","sqrt","xy2r","xy2a","ra2xy","r","pathCorner","pathSector","da","am","ap","rb","max","min","rm","rp","pathCornerForPolygons","va0","va1","xy0","xy1","innerPts","outerPts","m","mperp","midPts","dx","dy","zoomPrep","polarLayoutNow","getLuminance","makeZoombox","makeCorners","clampAndSetR0R1","rr0","rr1","applyZoomMove","path1","cpath","transitionZoombox","updateObj","computeZoomUpdates","emit","zoomMove","findPolygonRadius","xy","findIntersectionXY","zoomMoveForPolygons","a1","vangles0","vangles1","zoomDone","removeZoombox","showDoubleClickNotifier","update","newRng","zoomClick","numClicks","clickMode","clickmode","k","click","prepFn","startX","startY","dragModeNow","dragmode","bbox","getBoundingClientRect","_calcInverseTransform","inverse","_invTransform","_invScaleX","_invScaleY","transformedCoords","apply3DTransform","left","top","offset","findPolygonOffset","clickFn","moveFn","doneFn","init","rngIndex","bl","radialDragBoxSize","bl2","angle0","rl0","rl1","rbase","tx","ty","className","radialDrag","makeRectDragger","moveFn2","angle1","rprime","dvec","rvec","comp","dot","isNaN","rotateMove","rerangeMove","computeRadialAxisUpdates","fullLayoutNow","dr","hasRegl","traceType","moduleCalcData","moduleCalcDataVisible","filterVisible","_module","traceIs","clampFn","MINDRAG","dbs","angularDragBoxSize","angularDrag","pathAnnulus","scatterTraces","scatterPoints","scatterTextPoints","rot0","rot1","rrot1","trans","trans2","getTranslate","modHalf","isFullCircle","hideOutsideRangePoints","computeRotationUpdates","thetag","c2g","theta","c2l","fn","isPtInsidePolygon","isPtInsideSector","pathPolygon","pathPolygonAnnulus","key","val","s0","s1","arc","ax0","ay0","ax1","ay1","v","angleDist","findIndexOfMin","showAttr","attrs"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strRotate = Lib.strRotate;\nvar strTranslate = Lib.strTranslate;\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Plots = require('../plots');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvertCartesian = require('../cartesian/set_convert');\nvar setConvertPolar = require('./set_convert');\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\nvar dragBox = require('../cartesian/dragbox');\nvar dragElement = require('../../components/dragelement');\nvar Fx = require('../../components/fx');\nvar Titles = require('../../components/titles');\nvar prepSelect = require('../cartesian/select').prepSelect;\nvar selectOnClick = require('../cartesian/select').selectOnClick;\nvar clearSelect = require('../cartesian/select').clearSelect;\nvar setCursor = require('../../lib/setcursor');\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\nvar smithHelpers = require('../smith/helpers');\nvar smith = smithHelpers.smith;\nvar reactanceArc = smithHelpers.reactanceArc;\nvar resistanceArc = smithHelpers.resistanceArc;\nvar smithTransform = smithHelpers.smithTransform;\n\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\nfunction Polar(gd, id, isSmith) {\n    this.isSmith = isSmith || false;\n    this.id = id;\n    this.gd = gd;\n\n    this._hasClipOnAxisFalse = null;\n    this.vangles = null;\n    this.radialAxisAngle = null;\n    this.traceHash = {};\n    this.layers = {};\n    this.clipPaths = {};\n    this.clipIds = {};\n    this.viewInitial = {};\n\n    var fullLayout = gd._fullLayout;\n    var clipIdBase = 'clip' + fullLayout._uid + id;\n\n    this.clipIds.forTraces = clipIdBase + '-for-traces';\n    this.clipPaths.forTraces = fullLayout._clips.append('clipPath')\n        .attr('id', this.clipIds.forTraces);\n    this.clipPaths.forTraces.append('path');\n\n    this.framework = fullLayout['_' + (isSmith ? 'smith' : 'polar') + 'layer'].append('g')\n        .attr('class', id);\n\n    this.getHole = function(s) {\n        return this.isSmith ? 0 : s.hole;\n    };\n\n    this.getSector = function(s) {\n        return this.isSmith ? [0, 360] : s.sector;\n    };\n\n    this.getRadial = function(s) {\n        return this.isSmith ? s.realaxis : s.radialaxis;\n    };\n\n    this.getAngular = function(s) {\n        return this.isSmith ? s.imaginaryaxis : s.angularaxis;\n    };\n\n    if(!isSmith) {\n        // unfortunately, we have to keep track of some axis tick settings\n        // as polar subplots do not implement the 'ticks' editType\n        this.radialTickLayout = null;\n        this.angularTickLayout = null;\n    }\n}\n\nvar proto = Polar.prototype;\n\nmodule.exports = function createPolar(gd, id, isSmith) {\n    return new Polar(gd, id, isSmith);\n};\n\nproto.plot = function(polarCalcData, fullLayout) {\n    var _this = this;\n    var polarLayout = fullLayout[_this.id];\n\n    var found = false;\n    for(var i = 0; i < polarCalcData.length; i++) {\n        var trace = polarCalcData[i][0].trace;\n        if(trace.cliponaxis === false) {\n            found = true;\n            break;\n        }\n    }\n    _this._hasClipOnAxisFalse = found;\n\n    _this.updateLayers(fullLayout, polarLayout);\n    _this.updateLayout(fullLayout, polarLayout);\n    Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n    _this.updateFx(fullLayout, polarLayout);\n\n    if(_this.isSmith) {\n        delete polarLayout.realaxis.range;\n        delete polarLayout.imaginaryaxis.range;\n    }\n};\n\nproto.updateLayers = function(fullLayout, polarLayout) {\n    var _this = this;\n    var isSmith = _this.isSmith;\n    var layers = _this.layers;\n    var radialLayout = _this.getRadial(polarLayout);\n    var angularLayout = _this.getAngular(polarLayout);\n    var layerNames = constants.layerNames;\n\n    var frontPlotIndex = layerNames.indexOf('frontplot');\n    var layerData = layerNames.slice(0, frontPlotIndex);\n    var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n    var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n\n    if(isAngularAxisBelowTraces) layerData.push('angular-line');\n    if(isRadialAxisBelowTraces) layerData.push('radial-line');\n    if(isAngularAxisBelowTraces) layerData.push('angular-axis');\n    if(isRadialAxisBelowTraces) layerData.push('radial-axis');\n\n    layerData.push('frontplot');\n\n    if(!isAngularAxisBelowTraces) layerData.push('angular-line');\n    if(!isRadialAxisBelowTraces) layerData.push('radial-line');\n    if(!isAngularAxisBelowTraces) layerData.push('angular-axis');\n    if(!isRadialAxisBelowTraces) layerData.push('radial-axis');\n\n    var subLayer = (isSmith ? 'smith' : 'polar') + 'sublayer';\n\n    var join = _this.framework.selectAll('.' + subLayer)\n        .data(layerData, String);\n\n    join.enter().append('g')\n        .attr('class', function(d) { return subLayer + ' ' + d;})\n        .each(function(d) {\n            var sel = layers[d] = d3.select(this);\n\n            switch(d) {\n                case 'frontplot':\n                    // TODO add option to place in 'backplot' layer??\n                    if(!isSmith) {\n                        sel.append('g').classed('barlayer', true);\n                    }\n                    sel.append('g').classed('scatterlayer', true);\n                    break;\n                case 'backplot':\n                    sel.append('g').classed('maplayer', true);\n                    break;\n                case 'plotbg':\n                    layers.bg = sel.append('path');\n                    break;\n                case 'radial-grid':\n                    sel.style('fill', 'none');\n                    break;\n                case 'angular-grid':\n                    sel.style('fill', 'none');\n                    break;\n                case 'radial-line':\n                    sel.append('line').style('fill', 'none');\n                    break;\n                case 'angular-line':\n                    sel.append('path').style('fill', 'none');\n                    break;\n            }\n        });\n\n    join.order();\n};\n\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - getRadial(polarLayout) (aka radialLayout in this file):\n * - getAngular(polarLayout) (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends getRadial(polarLayout), adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends getAngular(polarLayout), adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\nproto.updateLayout = function(fullLayout, polarLayout) {\n    var _this = this;\n    var layers = _this.layers;\n    var gs = fullLayout._size;\n\n    // axis attributes\n    var radialLayout = _this.getRadial(polarLayout);\n    var angularLayout = _this.getAngular(polarLayout);\n    // layout domains\n    var xDomain = polarLayout.domain.x;\n    var yDomain = polarLayout.domain.y;\n    // offsets from paper edge to layout domain box\n    _this.xOffset = gs.l + gs.w * xDomain[0];\n    _this.yOffset = gs.t + gs.h * (1 - yDomain[1]);\n    // lengths of the layout domain box\n    var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n    var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]);\n    // sector to plot\n    var sector = _this.getSector(polarLayout);\n    _this.sectorInRad = sector.map(deg2rad);\n    var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n    var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n    var dySectorBBox = sectorBBox[3] - sectorBBox[1];\n    // aspect ratios\n    var arDomain = yLength / xLength;\n    var arSector = Math.abs(dySectorBBox / dxSectorBBox);\n    // actual lengths and domains of subplot box\n    var xLength2, yLength2;\n    var xDomain2, yDomain2;\n    var gap;\n    if(arDomain > arSector) {\n        xLength2 = xLength;\n        yLength2 = xLength * arSector;\n        gap = (yLength - yLength2) / gs.h / 2;\n        xDomain2 = [xDomain[0], xDomain[1]];\n        yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n    } else {\n        xLength2 = yLength / arSector;\n        yLength2 = yLength;\n        gap = (xLength - xLength2) / gs.w / 2;\n        xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n        yDomain2 = [yDomain[0], yDomain[1]];\n    }\n    _this.xLength2 = xLength2;\n    _this.yLength2 = yLength2;\n    _this.xDomain2 = xDomain2;\n    _this.yDomain2 = yDomain2;\n    // actual offsets from paper edge to the subplot box top-left corner\n    var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n    var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]);\n    // circle radius in px\n    var radius = _this.radius = xLength2 / dxSectorBBox;\n    // 'inner' radius in px (when polar.hole is set)\n    var innerRadius = _this.innerRadius = _this.getHole(polarLayout) * radius;\n    // circle center position in px\n    var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n    var cy = _this.cy = yOffset2 + radius * sectorBBox[3];\n    // circle center in the coordinate system of plot area\n    var cxx = _this.cxx = cx - xOffset2;\n    var cyy = _this.cyy = cy - yOffset2;\n\n    var side = radialLayout.side;\n    var trueSide;\n    if(side === 'counterclockwise') {\n        trueSide = side;\n        side = 'top';\n    } else if(side === 'clockwise') {\n        trueSide = side;\n        side = 'bottom';\n    }\n\n    _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n        // make this an 'x' axis to make positioning (especially rotation) easier\n        _id: 'x',\n        // convert to 'x' axis equivalent\n        side: side,\n        // keep track of real side\n        _trueSide: trueSide,\n        // spans length 1 radius\n        domain: [innerRadius / gs.w, radius / gs.w]\n    });\n\n    _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n        side: 'right',\n        // to get auto nticks right\n        domain: [0, Math.PI],\n        // don't pass through autorange logic\n        autorange: false\n    });\n\n    _this.doAutoRange(fullLayout, polarLayout);\n    // N.B. this sets _this.vangles\n    _this.updateAngularAxis(fullLayout, polarLayout);\n    // N.B. this sets _this.radialAxisAngle\n    _this.updateRadialAxis(fullLayout, polarLayout);\n    _this.updateRadialAxisTitle(fullLayout, polarLayout);\n\n    _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n        _id: 'x',\n        domain: xDomain2\n    });\n\n    _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n        _id: 'y',\n        domain: yDomain2\n    });\n\n    var dPath = _this.pathSubplot();\n\n    _this.clipPaths.forTraces.select('path')\n        .attr('d', dPath)\n        .attr('transform', strTranslate(cxx, cyy));\n\n    layers.frontplot\n        .attr('transform', strTranslate(xOffset2, yOffset2))\n        .call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n\n    layers.bg\n        .attr('d', dPath)\n        .attr('transform', strTranslate(cx, cy))\n        .call(Color.fill, polarLayout.bgcolor);\n};\n\nproto.mockAxis = function(fullLayout, polarLayout, axLayout, opts) {\n    var ax = Lib.extendFlat({}, axLayout, opts);\n    setConvertPolar(ax, polarLayout, fullLayout);\n    return ax;\n};\n\nproto.mockCartesianAxis = function(fullLayout, polarLayout, opts) {\n    var _this = this;\n    var isSmith = _this.isSmith;\n    var axId = opts._id;\n\n    var ax = Lib.extendFlat({type: 'linear'}, opts);\n    setConvertCartesian(ax, fullLayout);\n\n    var bboxIndices = {\n        x: [0, 2],\n        y: [1, 3]\n    };\n\n    ax.setRange = function() {\n        var sectorBBox = _this.sectorBBox;\n        var ind = bboxIndices[axId];\n        var rl = _this.radialAxis._rl;\n        var drl = (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout));\n        ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n    };\n\n    ax.isPtWithinRange = axId === 'x' && !isSmith ?\n        function(d) { return _this.isPtInside(d); } :\n        function() { return true; };\n\n    ax.setRange();\n    ax.setScale();\n\n    return ax;\n};\n\nproto.doAutoRange = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var radialAxis = _this.radialAxis;\n    var radialLayout = _this.getRadial(polarLayout);\n\n    doAutoRange(gd, radialAxis);\n\n    var rng = radialAxis.range;\n    radialLayout.range = rng.slice();\n    radialLayout._input.range = rng.slice();\n\n    radialAxis._rl = [\n        radialAxis.r2l(rng[0], null, 'gregorian'),\n        radialAxis.r2l(rng[1], null, 'gregorian')\n    ];\n};\n\nproto.updateRadialAxis = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialLayout = _this.getRadial(polarLayout);\n    var a0 = mod(_this.getSector(polarLayout)[0], 360);\n    var ax = _this.radialAxis;\n    var hasRoomForIt = innerRadius < radius;\n\n    var isSmith = _this.isSmith;\n    if(!isSmith) {\n        _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n        _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n\n        ax.setGeometry();\n    }\n\n    // rotate auto tick labels by 180 if in quadrant II and III to make them\n    // readable from left-to-right\n    //\n    // TODO try moving deeper in Axes.drawLabels for better results?\n    if(ax.tickangle === 'auto' && (a0 > 90 && a0 <= 270)) {\n        ax.tickangle = 180;\n    }\n\n    // easier to set rotate angle with custom translate function\n    var transFn = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([d.x, 0]));\n            return strTranslate(t[0] - cx, t[1] - cy);\n        } :\n        function(d) {\n            return strTranslate(ax.l2p(d.x) + innerRadius, 0);\n        };\n\n    // set special grid path function\n    var gridPathFn = isSmith ?\n        function(d) {\n            return resistanceArc(_this, d.x, -Infinity, Infinity);\n        } :\n        function(d) {\n            return _this.pathArc(ax.r2p(d.x) + innerRadius);\n        };\n\n    var newTickLayout = strTickLayout(radialLayout);\n    if(_this.radialTickLayout !== newTickLayout) {\n        layers['radial-axis'].selectAll('.xtick').remove();\n        _this.radialTickLayout = newTickLayout;\n    }\n\n    if(hasRoomForIt) {\n        ax.setScale();\n\n        var labelShift = 0;\n\n        var vals = isSmith ?\n            (ax.tickvals || []).filter(function(x) {\n                // filter negative\n                return x >= 0;\n            }).map(function(x) {\n                return Axes.tickText(ax, x, true, false);\n            }) : Axes.calcTicks(ax);\n\n        var valsClipped = isSmith ? vals : Axes.clipEnds(ax, vals);\n        var tickSign = Axes.getTickSigns(ax)[2];\n        if(isSmith) {\n            if(\n                (ax.ticks === 'top' && ax.side === 'bottom') ||\n                (ax.ticks === 'bottom' && ax.side === 'top')\n            ) {\n                // invert sign\n                tickSign = -tickSign;\n            }\n\n            if(ax.ticks === 'top' && ax.side === 'top') labelShift = -ax.ticklen;\n            if(ax.ticks === 'bottom' && ax.side === 'bottom') labelShift = ax.ticklen;\n        }\n\n        Axes.drawTicks(gd, ax, {\n            vals: vals,\n            layer: layers['radial-axis'],\n            path: Axes.makeTickPath(ax, 0, tickSign),\n            transFn: transFn,\n            crisp: false\n        });\n\n        Axes.drawGrid(gd, ax, {\n            vals: valsClipped,\n            layer: layers['radial-grid'],\n            path: gridPathFn,\n            transFn: Lib.noop,\n            crisp: false\n        });\n\n        Axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: layers['radial-axis'],\n            transFn: transFn,\n            labelFns: Axes.makeLabelFns(ax, labelShift)\n        });\n    }\n\n    // stash 'actual' radial axis angle for drag handlers (in degrees)\n    var angle = _this.radialAxisAngle = _this.vangles ?\n        rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) :\n        radialLayout.angle;\n\n    var tLayer = strTranslate(cx, cy);\n    var tLayer2 = tLayer + strRotate(-angle);\n\n    updateElement(\n        layers['radial-axis'],\n        hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks),\n        {transform: tLayer2}\n    );\n\n    updateElement(\n        layers['radial-grid'],\n        hasRoomForIt && radialLayout.showgrid,\n        {transform: isSmith ? '' : tLayer}\n    );\n\n    updateElement(\n        layers['radial-line'].select('line'),\n        hasRoomForIt && radialLayout.showline,\n        {\n            x1: isSmith ? -radius : innerRadius,\n            y1: 0,\n            x2: radius,\n            y2: 0,\n            transform: tLayer2\n        }\n    )\n    .attr('stroke-width', radialLayout.linewidth)\n    .call(Color.stroke, radialLayout.linecolor);\n};\n\nproto.updateRadialAxisTitle = function(fullLayout, polarLayout, _angle) {\n    if(this.isSmith) return;\n\n    var _this = this;\n    var gd = _this.gd;\n    var radius = _this.radius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialLayout = _this.getRadial(polarLayout);\n    var titleClass = _this.id + 'title';\n\n    var pad = 0;\n\n    // Hint: no need to check if there is in fact a title.text set\n    // because if plot is editable, pad needs to be calculated anyways\n    // to properly show placeholder text when title is empty.\n    if(radialLayout.title) {\n        var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n        var ts = radialLayout.title.font.size;\n        var side = radialLayout.side;\n        pad =\n            side === 'top' ? ts :\n            side === 'counterclockwise' ?\n                -(h + ts * 0.4) :\n                h + ts * 0.8;\n    }\n\n    var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n\n    var angleRad = deg2rad(angle);\n    var cosa = Math.cos(angleRad);\n    var sina = Math.sin(angleRad);\n\n    var x = cx + (radius / 2) * cosa + pad * sina;\n    var y = cy - (radius / 2) * sina + pad * cosa;\n\n    _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n        propContainer: radialLayout,\n        propName: _this.id + '.radialaxis.title',\n        placeholder: _(gd, 'Click to enter radial axis title'),\n        attributes: {\n            x: x,\n            y: y,\n            'text-anchor': 'middle'\n        },\n        transform: {rotate: -angle}\n    });\n};\n\nproto.updateAngularAxis = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var angularLayout = _this.getAngular(polarLayout);\n    var ax = _this.angularAxis;\n\n    var isSmith = _this.isSmith;\n    if(!isSmith) {\n        _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n\n        ax.setGeometry();\n        ax.setScale();\n    }\n\n    // 't'ick to 'g'eometric radians is used all over the place here\n    var t2g = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([0, d.x]));\n            return Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n        } :\n        function(d) { return ax.t2g(d.x); };\n\n    // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n    if(ax.type === 'linear' && ax.thetaunit === 'radians') {\n        ax.tick0 = rad2deg(ax.tick0);\n        ax.dtick = rad2deg(ax.dtick);\n    }\n\n    var _transFn = function(rad) {\n        return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n    };\n\n    var transFn = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([0, d.x]));\n            return strTranslate(t[0], t[1]);\n        } :\n        function(d) {\n            return _transFn(t2g(d));\n        };\n\n    var transFn2 = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([0, d.x]));\n            var rad = Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n            return strTranslate(t[0], t[1]) + strRotate(-rad2deg(rad));\n        } :\n        function(d) {\n            var rad = t2g(d);\n            return _transFn(rad) + strRotate(-rad2deg(rad));\n        };\n\n    var gridPathFn = isSmith ?\n        function(d) {\n            return reactanceArc(_this, d.x, 0, Infinity);\n        } :\n        function(d) {\n            var rad = t2g(d);\n            var cosRad = Math.cos(rad);\n            var sinRad = Math.sin(rad);\n            return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] +\n                'L' + [cx + radius * cosRad, cy - radius * sinRad];\n        };\n\n    var out = Axes.makeLabelFns(ax, 0);\n    var labelStandoff = out.labelStandoff;\n    var labelFns = {};\n\n    labelFns.xFn = function(d) {\n        var rad = t2g(d);\n        return Math.cos(rad) * labelStandoff;\n    };\n\n    labelFns.yFn = function(d) {\n        var rad = t2g(d);\n        var ff = Math.sin(rad) > 0 ? 0.2 : 1;\n        return -Math.sin(rad) * (labelStandoff + d.fontSize * ff) +\n            Math.abs(Math.cos(rad)) * (d.fontSize * MID_SHIFT);\n    };\n\n    labelFns.anchorFn = function(d) {\n        var rad = t2g(d);\n        var cos = Math.cos(rad);\n        return Math.abs(cos) < 0.1 ?\n            'middle' :\n            (cos > 0 ? 'start' : 'end');\n    };\n\n    labelFns.heightFn = function(d, a, h) {\n        var rad = t2g(d);\n        return -0.5 * (1 + Math.sin(rad)) * h;\n    };\n\n    var newTickLayout = strTickLayout(angularLayout);\n    if(_this.angularTickLayout !== newTickLayout) {\n        layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n        _this.angularTickLayout = newTickLayout;\n    }\n\n    var vals = isSmith ?\n        [Infinity].concat(ax.tickvals || []).map(function(x) {\n            return Axes.tickText(ax, x, true, false);\n        }) : Axes.calcTicks(ax);\n\n    if(isSmith) {\n        vals[0].text = '∞';\n        vals[0].fontSize *= 1.75;\n    }\n\n    // angle of polygon vertices in geometric radians (null means circles)\n    // TODO what to do when ax.period > ax._categories ??\n    var vangles;\n    if(polarLayout.gridshape === 'linear') {\n        vangles = vals.map(t2g);\n\n        // ax._vals should be always ordered, make them\n        // always turn counterclockwise for convenience here\n        if(Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n            vangles = vangles.slice().reverse();\n        }\n    } else {\n        vangles = null;\n    }\n    _this.vangles = vangles;\n\n    // Use tickval filter for category axes instead of tweaking\n    // the range w.r.t sector, so that sectors that cross 360 can\n    // show all their ticks.\n    if(ax.type === 'category') {\n        vals = vals.filter(function(d) {\n            return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n        });\n    }\n\n    if(ax.visible) {\n        var tickSign = ax.ticks === 'inside' ? -1 : 1;\n\n        var pad = (ax.linewidth || 1) / 2;\n\n        Axes.drawTicks(gd, ax, {\n            vals: vals,\n            layer: layers['angular-axis'],\n            path: 'M' + (tickSign * pad) + ',0h' + (tickSign * ax.ticklen),\n            transFn: transFn2,\n            crisp: false\n        });\n\n        Axes.drawGrid(gd, ax, {\n            vals: vals,\n            layer: layers['angular-grid'],\n            path: gridPathFn,\n            transFn: Lib.noop,\n            crisp: false\n        });\n\n        Axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: layers['angular-axis'],\n            repositionOnUpdate: true,\n            transFn: transFn,\n            labelFns: labelFns\n        });\n    }\n\n    // TODO maybe two arcs is better here?\n    // maybe split style attributes between inner and outer angular axes?\n\n    updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n        d: _this.pathSubplot(),\n        transform: strTranslate(cx, cy)\n    })\n    .attr('stroke-width', angularLayout.linewidth)\n    .call(Color.stroke, angularLayout.linecolor);\n};\n\nproto.updateFx = function(fullLayout, polarLayout) {\n    if(!this.gd._context.staticPlot) {\n        var hasDrag = !this.isSmith;\n        if(hasDrag) {\n            this.updateAngularDrag(fullLayout);\n            this.updateRadialDrag(fullLayout, polarLayout, 0);\n            this.updateRadialDrag(fullLayout, polarLayout, 1);\n        }\n        this.updateHoverAndMainDrag(fullLayout);\n    }\n};\n\nproto.updateHoverAndMainDrag = function(fullLayout) {\n    var _this = this;\n    var isSmith = _this.isSmith;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var zoomlayer = fullLayout._zoomlayer;\n    var MINZOOM = constants.MINZOOM;\n    var OFFEDGE = constants.OFFEDGE;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var cxx = _this.cxx;\n    var cyy = _this.cyy;\n    var sectorInRad = _this.sectorInRad;\n    var vangles = _this.vangles;\n    var radialAxis = _this.radialAxis;\n    var clampTiny = helpers.clampTiny;\n    var findXYatLength = helpers.findXYatLength;\n    var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n    var chw = constants.cornerHalfWidth;\n    var chl = constants.cornerLen / 2;\n\n    var scaleX;\n    var scaleY;\n\n    var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', 'crosshair');\n\n    d3.select(mainDrag)\n        .attr('d', _this.pathSubplot())\n        .attr('transform', strTranslate(cx, cy));\n\n    mainDrag.onmousemove = function(evt) {\n        Fx.hover(gd, evt, _this.id);\n        gd._fullLayout._lasthover = mainDrag;\n        gd._fullLayout._hoversubplot = _this.id;\n    };\n\n    mainDrag.onmouseout = function(evt) {\n        if(gd._dragging) return;\n        dragElement.unhover(gd, evt);\n    };\n\n    var dragOpts = {\n        element: mainDrag,\n        gd: gd,\n        subplot: _this.id,\n        plotinfo: {\n            id: _this.id,\n            xaxis: _this.xaxis,\n            yaxis: _this.yaxis\n        },\n        xaxes: [_this.xaxis],\n        yaxes: [_this.yaxis]\n    };\n\n    // mouse px position at drag start (0), move (1)\n    var x0, y0;\n    // radial distance from circle center at drag start (0), move (1)\n    var r0, r1;\n    // zoombox persistent quantities\n    var path0, dimmed, lum;\n    // zoombox, corners elements\n    var zb, corners;\n\n    function norm(x, y) {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    function xy2r(x, y) {\n        return norm(x - cxx, y - cyy);\n    }\n\n    function xy2a(x, y) {\n        return Math.atan2(cyy - y, x - cxx);\n    }\n\n    function ra2xy(r, a) {\n        return [r * Math.cos(a), r * Math.sin(-a)];\n    }\n\n    function pathCorner(r, a) {\n        if(r === 0) return _this.pathSector(2 * chw);\n\n        var da = chl / r;\n        var am = a - da;\n        var ap = a + da;\n        var rb = Math.max(0, Math.min(r, radius));\n        var rm = rb - chw;\n        var rp = rb + chw;\n\n        return 'M' + ra2xy(rm, am) +\n            'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) +\n            'L' + ra2xy(rp, ap) +\n            'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) +\n            'Z';\n    }\n\n    // (x,y) is the pt at middle of the va0 <-> va1 edge\n    //\n    // ... we could eventually add another mode for cursor\n    // angles 'close to' enough to a particular vertex.\n    function pathCornerForPolygons(r, va0, va1) {\n        if(r === 0) return _this.pathSector(2 * chw);\n\n        var xy0 = ra2xy(r, va0);\n        var xy1 = ra2xy(r, va1);\n        var x = clampTiny((xy0[0] + xy1[0]) / 2);\n        var y = clampTiny((xy0[1] + xy1[1]) / 2);\n        var innerPts, outerPts;\n\n        if(x && y) {\n            var m = y / x;\n            var mperp = -1 / m;\n            var midPts = findXYatLength(chw, m, x, y);\n            innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n            outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n        } else {\n            var dx, dy;\n            if(y) {\n                // horizontal handles\n                dx = chl;\n                dy = chw;\n            } else {\n                // vertical handles\n                dx = chw;\n                dy = chl;\n            }\n            innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n            outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n        }\n\n        return 'M' + innerPts.join('L') +\n            'L' + outerPts.reverse().join('L') + 'Z';\n    }\n\n    function zoomPrep() {\n        r0 = null;\n        r1 = null;\n        path0 = _this.pathSubplot();\n        dimmed = false;\n\n        var polarLayoutNow = gd._fullLayout[_this.id];\n        lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n\n        zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n        zb.attr('fill-rule', 'evenodd');\n        corners = dragBox.makeCorners(zoomlayer, cx, cy);\n        clearSelect(gd);\n    }\n\n    // N.B. this sets scoped 'r0' and 'r1'\n    // return true if 'valid' zoom distance, false otherwise\n    function clampAndSetR0R1(rr0, rr1) {\n        rr1 = Math.max(Math.min(rr1, radius), innerRadius);\n\n        // starting or ending drag near center (outer edge),\n        // clamps radial distance at origin (at r=radius)\n        if(rr0 < OFFEDGE) rr0 = 0;\n        else if((radius - rr0) < OFFEDGE) rr0 = radius;\n        else if(rr1 < OFFEDGE) rr1 = 0;\n        else if((radius - rr1) < OFFEDGE) rr1 = radius;\n\n        // make sure r0 < r1,\n        // to get correct fill pattern in path1 below\n        if(Math.abs(rr1 - rr0) > MINZOOM) {\n            if(rr0 < rr1) {\n                r0 = rr0;\n                r1 = rr1;\n            } else {\n                r0 = rr1;\n                r1 = rr0;\n            }\n            return true;\n        } else {\n            r0 = null;\n            r1 = null;\n            return false;\n        }\n    }\n\n    function applyZoomMove(path1, cpath) {\n        path1 = path1 || path0;\n        cpath = cpath || 'M0,0Z';\n\n        zb.attr('d', path1);\n        corners.attr('d', cpath);\n        dragBox.transitionZoombox(zb, corners, dimmed, lum);\n        dimmed = true;\n\n        var updateObj = {};\n        computeZoomUpdates(updateObj);\n        gd.emit('plotly_relayouting', updateObj);\n    }\n\n    function zoomMove(dx, dy) {\n        dx = dx * scaleX;\n        dy = dy * scaleY;\n\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n\n        var rr0 = xy2r(x0, y0);\n        var rr1 = Math.min(xy2r(x1, y1), radius);\n        var a0 = xy2a(x0, y0);\n        var path1;\n        var cpath;\n\n        if(clampAndSetR0R1(rr0, rr1)) {\n            path1 = path0 + _this.pathSector(r1);\n            if(r0) path1 += _this.pathSector(r0);\n            // keep 'starting' angle\n            cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n        }\n        applyZoomMove(path1, cpath);\n    }\n\n    function findPolygonRadius(x, y, va0, va1) {\n        var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n        return norm(xy[0], xy[1]);\n    }\n\n    function zoomMoveForPolygons(dx, dy) {\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n        var a0 = xy2a(x0, y0);\n        var a1 = xy2a(x1, y1);\n        var vangles0 = findEnclosingVertexAngles(a0, vangles);\n        var vangles1 = findEnclosingVertexAngles(a1, vangles);\n        var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n        var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n        var path1;\n        var cpath;\n\n        if(clampAndSetR0R1(rr0, rr1)) {\n            path1 = path0 + _this.pathSector(r1);\n            if(r0) path1 += _this.pathSector(r0);\n            // keep 'starting' angle here too\n            cpath = [\n                pathCornerForPolygons(r0, vangles0[0], vangles0[1]),\n                pathCornerForPolygons(r1, vangles0[0], vangles0[1])\n            ].join(' ');\n        }\n        applyZoomMove(path1, cpath);\n    }\n\n    function zoomDone() {\n        dragBox.removeZoombox(gd);\n\n        if(r0 === null || r1 === null) return;\n        var updateObj = {};\n        computeZoomUpdates(updateObj);\n\n        dragBox.showDoubleClickNotifier(gd);\n\n        Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    function computeZoomUpdates(update) {\n        var rl = radialAxis._rl;\n        var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n        var newRng = [\n            rl[0] + (r0 - innerRadius) * m,\n            rl[0] + (r1 - innerRadius) * m\n        ];\n        update[_this.id + '.radialaxis.range'] = newRng;\n    }\n\n    function zoomClick(numClicks, evt) {\n        var clickMode = gd._fullLayout.clickmode;\n\n        dragBox.removeZoombox(gd);\n\n        // TODO double once vs twice logic (autorange vs fixed range)\n        if(numClicks === 2) {\n            var updateObj = {};\n            for(var k in _this.viewInitial) {\n                updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n            }\n\n            gd.emit('plotly_doubleclick', null);\n            Registry.call('_guiRelayout', gd, updateObj);\n        }\n\n        if(clickMode.indexOf('select') > -1 && numClicks === 1) {\n            selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n        }\n\n        if(clickMode.indexOf('event') > -1) {\n            Fx.click(gd, evt, _this.id);\n        }\n    }\n\n    dragOpts.prepFn = function(evt, startX, startY) {\n        var dragModeNow = gd._fullLayout.dragmode;\n\n        var bbox = mainDrag.getBoundingClientRect();\n        gd._fullLayout._calcInverseTransform(gd);\n        var inverse = gd._fullLayout._invTransform;\n        scaleX = gd._fullLayout._invScaleX;\n        scaleY = gd._fullLayout._invScaleY;\n        var transformedCoords = Lib.apply3DTransform(inverse)(startX - bbox.left, startY - bbox.top);\n        x0 = transformedCoords[0];\n        y0 = transformedCoords[1];\n\n        // need to offset x/y as bbox center does not\n        // match origin for asymmetric polygons\n        if(vangles) {\n            var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n            x0 += cxx + offset[0];\n            y0 += cyy + offset[1];\n        }\n\n        switch(dragModeNow) {\n            case 'zoom':\n                dragOpts.clickFn = zoomClick;\n\n                if(!isSmith) {\n                    if(vangles) {\n                        dragOpts.moveFn = zoomMoveForPolygons;\n                    } else {\n                        dragOpts.moveFn = zoomMove;\n                    }\n\n                    dragOpts.doneFn = zoomDone;\n                    zoomPrep(evt, startX, startY);\n                }\n                break;\n            case 'select':\n            case 'lasso':\n                prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n                break;\n        }\n    };\n\n    dragElement.init(dragOpts);\n};\n\nproto.updateRadialDrag = function(fullLayout, polarLayout, rngIndex) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialAxis = _this.radialAxis;\n    var bl = constants.radialDragBoxSize;\n    var bl2 = bl / 2;\n\n    if(!radialAxis.visible) return;\n\n    var angle0 = deg2rad(_this.radialAxisAngle);\n    var rl = radialAxis._rl;\n    var rl0 = rl[0];\n    var rl1 = rl[1];\n    var rbase = rl[rngIndex];\n    var m = 0.75 * (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout)) / radius;\n\n    var tx, ty, className;\n    if(rngIndex) {\n        tx = cx + (radius + bl2) * Math.cos(angle0);\n        ty = cy - (radius + bl2) * Math.sin(angle0);\n        className = 'radialdrag';\n    } else {\n        // the 'inner' box can get called:\n        // - when polar.hole>0\n        // - when polar.sector isn't a full circle\n        // otherwise it is hidden behind the main drag.\n        tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n        ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n        className = 'radialdrag-inner';\n    }\n\n    var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n    var dragOpts = {element: radialDrag, gd: gd};\n\n    updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n        transform: strTranslate(tx, ty)\n    });\n\n    // move function (either rotate or re-range flavor)\n    var moveFn2;\n    // rotate angle on done\n    var angle1;\n    // re-range range[1] (or range[0]) on done\n    var rprime;\n\n    function moveFn(dx, dy) {\n        if(moveFn2) {\n            moveFn2(dx, dy);\n        } else {\n            var dvec = [dx, -dy];\n            var rvec = [Math.cos(angle0), Math.sin(angle0)];\n            var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec)));\n\n            // mostly perpendicular motions rotate,\n            // mostly parallel motions re-range\n            if(!isNaN(comp)) {\n                moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n            }\n        }\n\n        var update = {};\n        computeRadialAxisUpdates(update);\n        gd.emit('plotly_relayouting', update);\n    }\n\n    function computeRadialAxisUpdates(update) {\n        if(angle1 !== null) {\n            update[_this.id + '.radialaxis.angle'] = angle1;\n        } else if(rprime !== null) {\n            update[_this.id + '.radialaxis.range[' + rngIndex + ']'] = rprime;\n        }\n    }\n\n    function doneFn() {\n        if(angle1 !== null) {\n            Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n        } else if(rprime !== null) {\n            Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n        }\n    }\n\n    function rotateMove(dx, dy) {\n        // disable for inner drag boxes\n        if(rngIndex === 0) return;\n\n        var x1 = tx + dx;\n        var y1 = ty + dy;\n\n        angle1 = Math.atan2(cy - y1, x1 - cx);\n        if(_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n        angle1 = rad2deg(angle1);\n\n        var transform = strTranslate(cx, cy) + strRotate(-angle1);\n        layers['radial-axis'].attr('transform', transform);\n        layers['radial-line'].select('line').attr('transform', transform);\n\n        var fullLayoutNow = _this.gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n        _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n    }\n\n    function rerangeMove(dx, dy) {\n        // project (dx, dy) unto unit radial axis vector\n        var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n        rprime = rbase - m * dr;\n\n        // make sure rprime does not change the range[0] -> range[1] sign\n        if((m > 0) !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n            rprime = null;\n            return;\n        }\n\n        var fullLayoutNow = gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n\n        // update radial range -> update c2g -> update _m,_b\n        radialAxis.range[rngIndex] = rprime;\n        radialAxis._rl[rngIndex] = rprime;\n        _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n\n        _this.xaxis.setRange();\n        _this.xaxis.setScale();\n        _this.yaxis.setRange();\n        _this.yaxis.setScale();\n\n        var hasRegl = false;\n\n        for(var traceType in _this.traceHash) {\n            var moduleCalcData = _this.traceHash[traceType];\n            var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n            var _module = moduleCalcData[0][0].trace._module;\n            _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n            if(Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n        }\n\n        if(hasRegl) {\n            clearGlCanvases(gd);\n            redrawReglTraces(gd);\n        }\n    }\n\n    dragOpts.prepFn = function() {\n        moveFn2 = null;\n        angle1 = null;\n        rprime = null;\n\n        dragOpts.moveFn = moveFn;\n        dragOpts.doneFn = doneFn;\n\n        clearSelect(gd);\n    };\n\n    dragOpts.clampFn = function(dx, dy) {\n        if(Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n            dx = 0;\n            dy = 0;\n        }\n        return [dx, dy];\n    };\n\n    dragElement.init(dragOpts);\n};\n\nproto.updateAngularDrag = function(fullLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var angularAxis = _this.angularAxis;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var cxx = _this.cxx;\n    var cyy = _this.cyy;\n    var dbs = constants.angularDragBoxSize;\n\n    var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', 'move');\n    var dragOpts = {element: angularDrag, gd: gd};\n\n    d3.select(angularDrag)\n        .attr('d', _this.pathAnnulus(radius, radius + dbs))\n        .attr('transform', strTranslate(cx, cy))\n        .call(setCursor, 'move');\n\n    function xy2a(x, y) {\n        return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n    }\n\n    // scatter trace, points and textpoints selections\n    var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n    var scatterPoints = scatterTraces.selectAll('.point');\n    var scatterTextPoints = scatterTraces.selectAll('.textpoint');\n\n    // mouse px position at drag start (0), move (1)\n    var x0, y0;\n    // angular axis angle rotation at drag start (0), move (1)\n    var rot0, rot1;\n    // induced radial axis rotation (only used on polygon grids)\n    var rrot1;\n    // angle about circle center at drag start\n    var a0;\n\n    function moveFn(dx, dy) {\n        var fullLayoutNow = _this.gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n\n        var x1 = x0 + dx * fullLayout._invScaleX;\n        var y1 = y0 + dy * fullLayout._invScaleY;\n        var a1 = xy2a(x1, y1);\n        var da = rad2deg(a1 - a0);\n        rot1 = rot0 + da;\n\n        layers.frontplot.attr('transform',\n            strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy])\n        );\n\n        if(_this.vangles) {\n            rrot1 = _this.radialAxisAngle + da;\n\n            var trans = strTranslate(cx, cy) + strRotate(-da);\n            var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n\n            layers.bg.attr('transform', trans);\n            layers['radial-grid'].attr('transform', trans);\n            layers['radial-axis'].attr('transform', trans2);\n            layers['radial-line'].select('line').attr('transform', trans2);\n            _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n        } else {\n            _this.clipPaths.forTraces.select('path').attr('transform',\n                strTranslate(cxx, cyy) + strRotate(da)\n            );\n        }\n\n        // 'un-rotate' marker and text points\n        scatterPoints.each(function() {\n            var sel = d3.select(this);\n            var xy = Drawing.getTranslate(sel);\n            sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n        });\n        scatterTextPoints.each(function() {\n            var sel = d3.select(this);\n            var tx = sel.select('text');\n            var xy = Drawing.getTranslate(sel);\n            // N.B rotate -> translate ordering matters\n            sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n        });\n\n        // update rotation -> range -> _m,_b\n        angularAxis.rotation = Lib.modHalf(rot1, 360);\n        _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n\n        if(_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n            scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n        }\n\n        var hasRegl = false;\n\n        for(var traceType in _this.traceHash) {\n            if(Registry.traceIs(traceType, 'gl')) {\n                var moduleCalcData = _this.traceHash[traceType];\n                var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n                var _module = moduleCalcData[0][0].trace._module;\n                _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n                if(moduleCalcDataVisible.length) hasRegl = true;\n            }\n        }\n\n        if(hasRegl) {\n            clearGlCanvases(gd);\n            redrawReglTraces(gd);\n        }\n\n        var update = {};\n        computeRotationUpdates(update);\n        gd.emit('plotly_relayouting', update);\n    }\n\n    function computeRotationUpdates(updateObj) {\n        updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n\n        if(_this.vangles) {\n            updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n        }\n    }\n\n    function doneFn() {\n        scatterTextPoints.select('text').attr('transform', null);\n\n        var updateObj = {};\n        computeRotationUpdates(updateObj);\n        Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    dragOpts.prepFn = function(evt, startX, startY) {\n        var polarLayoutNow = fullLayout[_this.id];\n        rot0 = polarLayoutNow.angularaxis.rotation;\n\n        var bbox = angularDrag.getBoundingClientRect();\n        x0 = startX - bbox.left;\n        y0 = startY - bbox.top;\n\n        gd._fullLayout._calcInverseTransform(gd);\n        var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n        x0 = transformedCoords[0];\n        y0 = transformedCoords[1];\n\n        a0 = xy2a(x0, y0);\n\n        dragOpts.moveFn = moveFn;\n        dragOpts.doneFn = doneFn;\n\n        clearSelect(gd);\n    };\n\n    // I don't what we should do in this case, skip we now\n    if(_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n        dragOpts.prepFn = Lib.noop;\n        setCursor(d3.select(angularDrag), null);\n    }\n\n    dragElement.init(dragOpts);\n};\n\nproto.isPtInside = function(d) {\n    if(this.isSmith) return true;\n\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var thetag = this.angularAxis.c2g(d.theta);\n    var radialAxis = this.radialAxis;\n    var r = radialAxis.c2l(d.r);\n    var rl = radialAxis._rl;\n\n    var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n    return fn(r, thetag, rl, sectorInRad, vangles);\n};\n\nproto.pathArc = function(r) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n    return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSector = function(r) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n    return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathAnnulus = function(r0, r1) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n    return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSubplot = function() {\n    var r0 = this.innerRadius;\n    var r1 = this.radius;\n    return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\n\nproto.fillViewInitialKey = function(key, val) {\n    if(!(key in this.viewInitial)) {\n        this.viewInitial[key] = val;\n    }\n};\n\nfunction strTickLayout(axLayout) {\n    var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n    if('side' in axLayout) out += axLayout.side;\n    return out;\n}\n\n// Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\nfunction computeSectorBBox(sector) {\n    var s0 = sector[0];\n    var s1 = sector[1];\n    var arc = s1 - s0;\n    var a0 = mod(s0, 360);\n    var a1 = a0 + arc;\n\n    var ax0 = Math.cos(deg2rad(a0));\n    var ay0 = Math.sin(deg2rad(a0));\n    var ax1 = Math.cos(deg2rad(a1));\n    var ay1 = Math.sin(deg2rad(a1));\n\n    var x0, y0, x1, y1;\n\n    if((a0 <= 90 && a1 >= 90) || (a0 > 90 && a1 >= 450)) {\n        y1 = 1;\n    } else if(ay0 <= 0 && ay1 <= 0) {\n        y1 = 0;\n    } else {\n        y1 = Math.max(ay0, ay1);\n    }\n\n    if((a0 <= 180 && a1 >= 180) || (a0 > 180 && a1 >= 540)) {\n        x0 = -1;\n    } else if(ax0 >= 0 && ax1 >= 0) {\n        x0 = 0;\n    } else {\n        x0 = Math.min(ax0, ax1);\n    }\n\n    if((a0 <= 270 && a1 >= 270) || (a0 > 270 && a1 >= 630)) {\n        y0 = -1;\n    } else if(ay0 >= 0 && ay1 >= 0) {\n        y0 = 0;\n    } else {\n        y0 = Math.min(ay0, ay1);\n    }\n\n    if(a1 >= 360) {\n        x1 = 1;\n    } else if(ax0 <= 0 && ax1 <= 0) {\n        x1 = 0;\n    } else {\n        x1 = Math.max(ax0, ax1);\n    }\n\n    return [x0, y0, x1, y1];\n}\n\nfunction snapToVertexAngle(a, vangles) {\n    var fn = function(v) { return Lib.angleDist(a, v); };\n    var ind = Lib.findIndexOfMin(vangles, fn);\n    return vangles[ind];\n}\n\nfunction updateElement(sel, showAttr, attrs) {\n    if(showAttr) {\n        sel.attr('display', null);\n        sel.attr(attrs);\n    } else if(sel) {\n        sel.attr('display', 'none');\n    }\n    return sel;\n}\n"]},"metadata":{},"sourceType":"script"}